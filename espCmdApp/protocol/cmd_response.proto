# cmd_response:
#   simple command/response access via USB to Arduino's I/O capabilities
#
# soft link this file to the IOC's boot directory to be found at run time

InTerminator = LF;
OutTerminator = LF;

num_ai {
  out "?#ai";
  in "NUM_AI %d";
}

num_bin {
  out "?#bi";
  in "NUM_BIN %d";
}
# StreamDevice interprets ReplyTimeout as an integer (often milliseconds).
# 1000 here avoids false timeouts on short USB/serial jitter.
ReplyTimeout = 1000;
#LockTimeout = 500;


ai_watch {
  out "!ai:watch \$1 %d";
  in "Ok";
}
# silence most error messages
ERROR_RESPONSE = "ERROR_.*";
@mismatch { in $ERROR_RESPONSE; }
ExtraInput = Ignore;

#     turn on diagnostics with these IOC shell commands:
#       asynSetTraceIOMask "usb0" 0 2
#       asynSetTraceMask   "usb0" 0 9

# ai
ai {
  out "?ai \$1";
  in "AI %*d %d";

}

# longout
ai_mean {
  out "?ai:mean \$1";
  in "AI_MEAN %*d %f";
}

# bi
bi {
  out "?bi \$1";
  in "BI %*d %d";
}

# bo
bo {
  out "!bo \$1 %d";
  in "Ok";
}

# longout
pwm {
  out "!pwm \$1 %d";
  in "Ok";
}

# ao
period {
  out "!t %u";
  in "Ok";
}

period_get {
  out "?t";
  in "PERIOD %d";
}

period_min {
  out "?t:min";
  in "%d";
}

period_max {
  out "?t:max";
  in "%d";
}

multiplier_set {
  out "!k %d";
  in "Ok";
}

multiplier_get {
  out "?k";
  in "MULTIPLIER %d";
}

multiplier_min {
  out "?k:min";
  in "%d";
}

multiplier_max {
  out "?k:max";
  in "%d";
}

# ai
rate {
  out "?rate";
  in "RATE %d";
}

# identity / firmware info
id {
  out "?id";
  in "%39[^\n]";
}

version {
  out "?v";
  in "%39[^\n]";
}

debug {
    ExtraInput = Error;
    out "%s";
  in "%39[^\n]";
}

pin_out {
  out "!pin %d 1";
  in "Ok";
}

pin_in {
  out "!pin %d 0";
  in "Ok";
}

pin_mode {
  out "!pin \$1 %d";
  in "Ok";
}

# Convenience: allow writing the remainder of the command as a string.
# Example:
#   caput -S ESP:pin "15 1"   -> sends "!pin 15 1"
#   caput -S ESP:bo  "15 0"   -> sends "!bo 15 0"
pin_mode_raw {
  out "!pin %s";
  in "Ok";
}

bo_raw {
  out "!bo %s";
  in "Ok";
}

